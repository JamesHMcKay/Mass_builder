#include "utils.hpp"

namespace utils
{
time_t t = time(0);   // get time now to print into generated files
struct tm * now = localtime( & t );

void get_data(vector<std::string> &A,int &n,const char *filename)
{

//cout << "reading file = " << filename << endl;
n=0;
std::ifstream input(filename);
std::string line;
while(getline(input, line)) {
      if (!line.length() || line[0] == '#')
         continue;
      std::istringstream iss(line);
      n=n+1;
   }
  
A.resize(n);

 input.close();

n=0;
std::ifstream input2(filename);
std::string line2;
while(getline(input2, line2)) {
    if (!line2.length() || line2[0] == '#')
       continue;
    std::istringstream iss2(line2);
  
  
  iss2>> A[n];
    n=n+1;
 }

 input2.close();


}



void get_data(vector<std::string> &A, vector<std::string> &B,int &n,const char *filename)
{


n=0;
std::ifstream input(filename);
std::string line;
int na=0,nb=0;
while(getline(input, line)) {
      if (!line.length() || line[0] == '#')
         continue;
      std::istringstream iss(line);
      std::string test;
      n=n+1;
  
      //cout << "test = " << line << endl;
      if (std::count( line.begin(), line.end(), ' ' )>0)
      {
      na=na+1;
      nb=nb+1;
      }
      else
      {
      na=na+1;
      }
   }
  

A.resize(na);
B.resize(nb);
n = na; // maybe set to maximum of the two
//cout << "na , nb = " << na << " " << nb << endl;
na=0,nb=0;

std::ifstream input2(filename);
std::string line2;
while(getline(input2, line2)) {
    if (!line2.length() || line2[0] == '#')
       continue;
    std::istringstream iss2(line2);
  if (std::count( line2.begin(), line2.end(), ' ' )>0)
  {
  iss2>> A[na] >> B[nb];
  na=na+1;
  nb=nb+1;
  }
  else
  {
  iss2>> A[na];
  na=na+1;
  }
    
 }
input.close();
input2.close();
}



void print_math_header(ofstream &file)
{


 /*MATH_PATH */  file<< "#!/Applications/Mathematica.app/Contents/MacOS/MathematicaScript -script"<<endl;
  //myfile<< "#!/Applications/Mathematica.app/Contents/MacOS/MathematicaScript -script\n"  // TODO change absolute path
  file << "(* ---------------------------------------------------- *)\n"
  << "(* This file has been automatically generated by stage_1.cpp, on "<< now->tm_mday << '-'
  << (now->tm_mon + 1) << '-'<< (now->tm_year + 1900) <<", do not edit *)\n"
  << "(* ---------------------------------------------------- *)\n"
  << "$LoadPhi = True;\n"
  << "$LoadTARCER = True;\n"
  <<"$LoadFeynArts = True;\n"
  << "<< FeynCalc/FeynCalc.m\n"
  <<"dm[mu_] := DiracMatrix[mu, Dimension -> D]\n"
  <<"dm[5] := DiracMatrix[5]\n"
  <<"ds[p_] := DiracSlash[p]\n"
  <<"SetOptions[DiracSlash, Dimension -> D, FeynCalcInternal -> True];\n"
  <<"SetOptions[DiracTrace, DiracTraceEvaluate -> True];\n"
  <<"$GenericMixing = True;\n";
}


void print_math_body(ofstream &file,int loop_order,string particle_full,string diagram,string model,string cwd)
{
 
  if (loop_order == 2)
  {
  file<<"t12 = CreateTopologies[2, 1 -> 1, ExcludeTopologies -> Internal];\n"
  <<"alldiags = InsertFields[t12, {"<<particle_full<<"} -> {"<<particle_full<<"},InsertionLevel -> {Particles}, GenericModel -> Lorentz,Model -> \""<<cwd<<"/models/"<<model<<"/"<<model<<"\"];\n"
  <<"subdiags0 =   DiagramExtract[alldiags, "<<diagram<<"]\n"
  //<<"Export[\""<<s_cwd<<"/current_diagram.pdf\",Paint[subdiags0]];\n"  // print the FA diagram to pdf in local directory
  <<"amp0 := FCFAConvert[CreateFeynAmp[subdiags0], IncomingMomenta -> {p}, OutgoingMomenta -> {p}, LoopMomenta -> {k1, k2} ,UndoChiralSplittings -> True,DropSumOver -> True, List -> False(*, ChangeDimension -> 4*)] // Contract\n" // TODO change dimension removed as done in 1 loop case below?
  <<"amp0 = amp0 /. MajoranaSpinor[p, mc] -> 1 /.Spinor[Momentum[p], mc, 1] -> 1;\n"
  <<"SetOptions[Eps, Dimension -> D];\n"
  <<"fullamp0 = (amp0) // DiracSimplify // FCMultiLoopTID[#, {k1, k2}] & //DiracSimplify;\n"
  <<"tfiamp0 = fullamp0 // ToTFI[#, k1, k2, p] & // ChangeDimension[#, 4] &;\n";
  }
  if (loop_order == 1)
  {
  file<<"t12 = CreateTopologies[1, 1 -> 1, ExcludeTopologies -> Internal];\n"
  <<"alldiags = InsertFields[t12, {"<<particle_full<<"} -> {"<<particle_full<<"},InsertionLevel -> {Particles}, GenericModel -> Lorentz,Model -> \""<<cwd<<"/models/"<<model<<"/"<<model<<"\"];\n"
  <<"subdiags0 =   DiagramExtract[alldiags, "<<diagram<<"]\n"
 // <<"Export[\""<<s_cwd<<"/current_diagram.pdf\",Paint[subdiags0]];\n"  // print the FA diagram to pdf in local directory
  <<"amp0 := FCFAConvert[CreateFeynAmp[subdiags0], IncomingMomenta -> {p}, OutgoingMomenta -> {p}, LoopMomenta -> {k1} ,UndoChiralSplittings -> True,DropSumOver -> True, List -> False] // Contract\n"
  <<"amp0 = amp0 /. MajoranaSpinor[p, mc] -> 1 /.Spinor[Momentum[p], mc, 1] -> 1;\n"
  <<"SetOptions[Eps, Dimension -> D];\n"
  <<"fullamp0 = (amp0) // DiracSimplify // FCMultiLoopTID[#, {k1}] & //DiracSimplify;\n"
  <<"tfiamp0 = fullamp0 // ToTFI[#, k1, p] & // ChangeDimension[#, 4] &;\n";
  }


}

void print_product(ofstream &myfile,string name_1,string name_2,string SEn)
{


  string elements1,elements2;
  stringstream _e1,_e2,_e3,_e4,_e5, _type1;
  string e1,e2,e3,e4,e5, type1;
  _type1 << name_1[0];
  _type1 >> type1;
  _e1 << name_1[1];_e1 >> e1;
  _e2 << name_1[2];_e2 >> e2;
  _e3 << name_1[3];_e3 >> e3;
  _e4 << name_1[4];_e4 >> e4;
  _e5 << name_1[5];_e5 >> e5;
  
  stringstream _f1,_f2,_f3,_f4,_f5, _type2;
  string f1,f2,f3,f4,f5, type2;
  _type2 << name_2[0];
  _type2 >> type2;
  
  if (type1 =="F"){goto end;}
  if (type2 =="F"){goto end;}
    
  _f1 << name_2[1];_f1 >> f1;
  _f2 << name_2[2];_f2 >> f2;
  _f3 << name_2[3];_f3 >> f3;
  _f4 << name_2[4];_f4 >> f4;
  _f5 << name_2[5];_f5 >> f5;


  if (type1=="A") elements1 = e1;
  if (type1=="B") elements1 = e1 + e2;
  if (type1=="J") elements1 = e1 + e2 + e3;
  if (type1=="T") elements1 = e1 + e2 + e3;
  if (type1=="K") elements1 = e1 + e2 + e3;
  if (type1=="V") elements1 = e1 + e2 + e3 + e4;

  if (type2=="A") elements2 = f1;
  if (type2=="B") elements2 = f1 + f2;
  if (type2=="J") elements2 = f1 + f2 + f3;
  if (type2=="T") elements2 = f1 + f2 + f3;
  if (type2=="K") elements2 = f1 + f2 + f3;
  if (type2=="V") elements2 = f1 + f2 + f3 + f4;



  myfile << type1 << elements1 << type2 << elements2 << " = ";
  if (type1=="A") myfile << "TAI[4, 0, {1, m" << elements1[0] << "}]";
  if (type1=="B") myfile << "TBI[4, Pair[Momentum[p],Momentum[p]], {{1, m" << elements1[0] << "}, {1, m" << elements1[1] << "}}]";
  if (type1=="J") myfile << "TJI[4, Pair[Momentum[p],Momentum[p]], {{1, m" << elements1[0] << "}, {1, m" << elements1[1] << "}, {1, m" << elements1[2] << "}}]";
  if (type1=="T") myfile << "TJI[4, Pair[Momentum[p],Momentum[p]], {{2, m" << elements1[0] << "}, {1, m" << elements1[1] << "}, {1, m" << elements1[2] << "}}]";
  if (type1=="K") myfile << "TJI[4, 0, {{1, m" << elements1[0] << "}, {1, m" << elements1[1] << "}, {1, m" << elements1[2] << "}}]";
  if (type1=="V") myfile << "TVI[4, Pair[Momentum[p],Momentum[p]], {{1, m" << elements1[0] << "}, {1, m" << elements1[1] << "}, {1, m" << elements1[2] << "}, {1, m" << elements1[3] << "}}]";
  myfile << " * ";
  if (type2=="A") myfile << "TAI[4, 0, {1, m" << elements2[0] << "}];";
  if (type2=="B") myfile << "TBI[4, Pair[Momentum[p],Momentum[p]], {{1, m" << elements2[0] << "}, {1, m" << elements2[1] << "}}];";
  if (type2=="J") myfile << "TJI[4, Pair[Momentum[p],Momentum[p]], {{1, m" << elements2[0] << "}, {1, m" << elements2[1] << "}, {1, m" << elements2[2] << "}}];";
  if (type2=="T") myfile << "TJI[4, Pair[Momentum[p],Momentum[p]], {{2, m" << elements2[0] << "}, {1, m" << elements2[1] << "}, {1, m" << elements2[2] << "}}];";
  if (type2=="K") myfile << "TJI[4, 0, {{1, m" << elements2[0] << "}, {1, m" << elements2[1] << "}, {1, m" << elements2[2] << "}}];";
  if (type2=="V") myfile << "TVI[4, Pair[Momentum[p],Momentum[p]], {{1, m" << elements2[0] << "}, {1, m" << elements2[1] << "}, {1, m" << elements2[2] << "}, {1, m" << elements2[3] << "}}];";
  myfile << endl;
  if ((type1 == type2) && (elements1==elements2)) myfile << "C"<< type1 << elements1 << type2 << elements2 << " = Coefficient["<<SEn<<","<< type1 << elements1 << ", 2];" << endl;
  else myfile << "C"<< type1 << elements1 << type2 << elements2 << " = - (1/2)* Coefficient["<<SEn<<","<< type1 << elements1 << type2 << elements2 << ", 1];" << endl;
  end:;
}



void print_A(ofstream &myfile, string elements,string SEn)
{
if (SEn == "SEn") myfile << "A"<< elements << " = " << "TAI[4, 0, {1, m" << elements[0] << "}];" << endl;
myfile << "CA"<< elements << " = Coefficient["<<SEn<<", A" << elements << ", 1];" << endl;
}

void print_B(ofstream &myfile, string elements,string SEn)
{
if (SEn == "SEn") myfile << "B"<< elements << " = " << "TBI[4, Pair[Momentum[p],Momentum[p]], {{1, m" << elements[0] << "}, {1, m" << elements[1] << "}}];" << endl;
myfile << "CB"<< elements << " = Coefficient["<<SEn<<", B" << elements << ", 1];" << endl;
}

void print_V(ofstream &myfile, string elements,string SEn)
{
if (SEn == "SEn") myfile << "V"<< elements << " = " << "TVI[4, Pair[Momentum[p],Momentum[p]], {{1, m" << elements[0] << "}, {1, m" << elements[1] << "}, {1, m" << elements[2] << "}, {1, m" << elements[3] << "}}];" << endl;
myfile << "CV"<< elements << " = Coefficient["<<SEn<<", V" << elements << ", 1];" << endl;
}

void print_T(ofstream &myfile, string elements,string SEn)
{
if (SEn == "SEn") myfile << "T"<< elements << " = " << "TJI[4, Pair[Momentum[p],Momentum[p]], {{2, m" << elements[0] << "}, {1, m" << elements[1] << "}, {1, m" << elements[2] << "}}];" << endl;
myfile << "CT"<< elements << " = Coefficient["<<SEn<<", T" << elements << ", 1];" << endl;
}

void print_J(ofstream &myfile, string elements,string SEn)
{
if (SEn == "SEn") myfile << "J"<< elements << " = " << "TJI[4, Pair[Momentum[p],Momentum[p]], {{1, m" << elements[0] << "}, {1, m" << elements[1] << "}, {1, m" << elements[2] << "}}];" << endl;
myfile << "CJ"<< elements << " = Coefficient["<<SEn<<", J" << elements << ", 1];" << endl;
}

void print_K(ofstream &myfile, string elements,string SEn)
{
if (SEn == "SEn") myfile << "K"<< elements << " = " << "TJI[4, 0, {{1, m" << elements[0] << "}, {1, m" << elements[1] << "}, {1, m" << elements[2] << "}}];" << endl;
myfile << "CK"<< elements << " = Coefficient["<<SEn<<", K" << elements << ", 1];" << endl;
}


void print_F(ofstream &myfile, string elements,string SEn)
{
if (SEn == "SEn") myfile << "F"<< elements << " = " << "TFI[4, Pair[Momentum[p],Momentum[p]], {{1, m" << elements[0] << "}, {1, m" << elements[1] << "}, {1, m" << elements[2] << "}, {1, m" << elements[3] << "}, {1, m" << elements[4] << "}}];" << endl;
myfile << "CF"<< elements << " = Coefficient["<<SEn<<", F" << elements << ", 1];" << endl;
}




bool check_done()
{

 
  std::ifstream file("output/result.txt");
  std::string str;
  std::string result;
  std::getline(file, str);
  result += str;
  
 
  // need to check if the result of diff is zero, if not then throw an error
  
  bool success = 0;
  if (result == "0") {cout << "Successful!!!" << endl, success = 1;}
  else { cout << "Something has gone terribly wrong, check the symmetries are being accounted for properly when writting the basis integrals \n" <<\
  "(and thus no double up of terms) and that all cross terms are being considered." << endl; success = 0;}
  
  return success;

}


std::string part_name_simple(std::string particle_name_full)
{
  stringstream _part_1,_part_2;
  string part_1,part_2;
  
  _part_1 << particle_name_full[0];
  _part_1 >> part_1;
  _part_2 << particle_name_full[2];
  _part_2 >> part_2;
  
  return part_1+part_2;

}

vector<string> remove_duplicates(vector<string> input,string warning)
{
vector<std::string> input_unique = input;
sort(input_unique.begin(),input_unique.end());
input_unique.erase( unique( input_unique.begin(), input_unique.end() ), input_unique.end() );
if (input.size() != input_unique.size())
{
cout << warning <<endl;
}
return input_unique;
}

vector<string> remove_duplicates(vector<string> input)
{
vector<std::string> input_unique = input;
sort(input_unique.begin(),input_unique.end());
input_unique.erase( unique( input_unique.begin(), input_unique.end() ), input_unique.end() );
return input_unique;
}

vector<char> remove_duplicates(vector<char> input,string warning)
{
vector<char> input_unique = input;
sort(input_unique.begin(),input_unique.end());
input_unique.erase( unique( input_unique.begin(), input_unique.end() ), input_unique.end() );
if (input.size() != input_unique.size())
{
cout << warning <<endl;
}
return input_unique;
}

vector<char> remove_duplicates(vector<char> input)
{
vector<char> input_unique = input;
sort(input_unique.begin(),input_unique.end());
input_unique.erase( unique( input_unique.begin(), input_unique.end() ), input_unique.end() );
return input_unique;
}



string char_to_string(char c)
{
stringstream ss;
string s;
ss << c;
ss >> s;
return s;
}


vector<int> find_string_lengths(vector<string> input)
{
vector<int> lengths;
for (unsigned int i = 0; i < input.size(); i++)
{
string input_temp = input[i];
lengths.push_back( input_temp.size() );
}
return lengths;

}



std::vector<std::string> extract_keys(std::map<std::string, Bases> const& input_map) {
std::vector<std::string> retval;
for (auto const& element : input_map) {
    retval.push_back(element.first);
}
return retval;
}












void print_base(ofstream &myfile, Bases base, string id, string SEn)
{
string type = base.type;

if (SEn == "SEn")
{

if (type == "F")
{
myfile << id << " = " << "TFI[4, Pair[Momentum[p],Momentum[p]], {{1, " << base.e1  << "}, {1, " << base.e2 << "}, {1, " << base.e3 << "}, {1, " << base.e4 << "}, {1, " << base.e5 << "}}];" << endl;
}
if (type == "A")
{
myfile << id << " = " << "TAI[4, 0, {1, " << base.e1 << "}];" << endl;
}
if (type == "B")
{
myfile << id << " = " << "TBI[4, Pair[Momentum[p],Momentum[p]], {{1, " << base.e1 << "}, {1, " << base.e2 << "}}];" << endl;
}
if (type == "V")
{
myfile << id << " = " << "TVI[4, Pair[Momentum[p],Momentum[p]], {{1, " << base.e1 << "}, {1, " << base.e2 << "}, {1, " << base.e3 << "}, {1, " << base.e4 << "}}];" << endl;
}

if (type == "T")
{
myfile << id << " = " << "TJI[4, Pair[Momentum[p],Momentum[p]], {{2, " << base.e1 << "}, {1, " << base.e2 << "}, {1, " << base.e3 << "}}];" << endl;
}

if (type == "J")
{
myfile << id << " = " << "TJI[4, Pair[Momentum[p],Momentum[p]], {{1, " << base.e1 << "}, {1, " << base.e2 << "}, {1, " << base.e3 << "}}];" << endl;
}

if (type == "K")
{
myfile << id << " = " << "TJI[4, 0, {{1, " << base.e1 << "}, {1, " << base.e2 << "}, {1, " << base.e3 << "}}];" << endl;
}
}

myfile << "C"<< id << " = Coefficient["<<SEn<<", " << id << ", 1];" << endl;
}






// print the basis integrals out in Mathematica notation
void print_math_basis(std::map<std::string, Bases> base_map, ofstream &myfile, string target)
{
  vector<string> bases_names = extract_keys(base_map);
  for (unsigned int i = 0; i < bases_names.size();i++)
  {
  Bases base_temp;
  base_temp = base_map[bases_names[i]];
  print_base(myfile, base_temp, bases_names[i], target);
  }
}






void print_base_product(ofstream &myfile,Bases base_1,Bases base_2,string SEn)
{


  string type1 = base_1.type;
  string type2 = base_2.type;
  
  if (type1 =="F"){goto end;}
  if (type2 =="F"){goto end;}



  myfile << base_1.short_name << base_2.short_name << " = ";
  if (type1=="A") myfile << "TAI[4, 0, {1, " << base_1.e1 << "}]";
  if (type1=="B") myfile << "TBI[4, Pair[Momentum[p],Momentum[p]], {{1, " << base_1.e1 << "}, {1, " << base_1.e2 << "}}]";
  if (type1=="J") myfile << "TJI[4, Pair[Momentum[p],Momentum[p]], {{1, " << base_1.e1 << "}, {1, " << base_1.e2 << "}, {1, " << base_1.e3 << "}}]";
  if (type1=="T") myfile << "TJI[4, Pair[Momentum[p],Momentum[p]], {{2, " << base_1.e1 << "}, {1, " << base_1.e2 << "}, {1, " << base_1.e3 << "}}]";
  if (type1=="K") myfile << "TJI[4, 0, {{1, " << base_1.e1 << "}, {1, " << base_1.e2 << "}, {1, " << base_1.e3 << "}}];";
  if (type1=="V") myfile << "TVI[4, Pair[Momentum[p],Momentum[p]], {{1, " << base_1.e1 << "}, {1, " << base_1.e2 << "}, {1, " << base_1.e3 << "}, {1, " << base_1.e4 << "}}]";
  myfile << " * ";
  if (type2=="A") myfile << "TAI[4, 0, {1, " << base_2.e1 << "}];";
  if (type2=="B") myfile << "TBI[4, Pair[Momentum[p],Momentum[p]], {{1, " << base_2.e1 << "}, {1, " << base_2.e2 << "}}];";
  if (type2=="J") myfile << "TJI[4, Pair[Momentum[p],Momentum[p]], {{1, " << base_2.e1 << "}, {1, " << base_2.e2 << "}, {1, " << base_2.e3 << "}}];";
  if (type2=="T") myfile << "TJI[4, Pair[Momentum[p],Momentum[p]], {{2, " << base_2.e1 << "}, {1, " << base_2.e2 << "}, {1, " << base_2.e3 << "}}];";
  if (type2=="K") myfile << "TJI[4, 0, {{1, " << base_2.e1 << "}, {1, " << base_2.e2 << "}, {1, " << base_2.e3 << "}}];;";
  if (type2=="V") myfile << "TVI[4, Pair[Momentum[p],Momentum[p]], {{1, " << base_2.e1 << "}, {1, " << base_2.e2 << "}, {1, " << base_2.e3 << "}, {1, " << base_2.e4 << "}}];";
  myfile << endl;
  if (base_1.short_name==base_2.short_name) myfile << "C"<< base_1.short_name << base_2.short_name << " = Coefficient["<<SEn<<","<< base_1.short_name << ", 2];" << endl;
  else myfile << "C"<< base_1.short_name << base_2.short_name << " = - (1/2)* Coefficient["<<SEn<<","<< base_1.short_name << base_2.short_name << ", 1];" << endl;
  end:;
}




// print the basis integrals out in Mathematica notation
void print_math_products(std::map<std::string, Bases> base_map, ofstream &myfile, string target)
{
  vector<string> bases_names = extract_keys(base_map);
  int n = bases_names.size();

  for (int i = 0; i<n;i++)
  {

  
  for (int j = 0; j<n;j++)
  {
  
  Bases base_1;
  base_1 = base_map[bases_names[i]];
  base_1.short_name = bases_names[i];
  Bases base_2;
  base_2 = base_map[bases_names[j]];
  base_2.short_name = bases_names[j];  // TODO make this an automatic get and set function perhaps, could do short_names nicer
  
  print_base_product(myfile,base_1,base_2,target);
  
  }
  }
}




}
