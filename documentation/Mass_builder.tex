\input{R1_template}

\begin{document}

\def\A{\mathcal{A}}
\def\B{\mathcal{B}}
\def\C{\mathcal{C}}

\graphicspath{ {Figures/}}

\title{Mass builder -- an interface tool for automated self energy calculation}
%
\author
{
  James McKay\thanksref{e1,addr1}
}
%
\thankstext{e1}{e-mail: j.mckay14@imperial.ac.uk}
%
\institute
{
  Imperial College London\label{addr1}
}
%
\date{\today}

\maketitle

\begin{abstract}

This program is designed to organise and simplify the calculation of two loop self energy amplitudes by creating a user friendly interface between the existing available programs.  Using the C++ language we generate the appropriate Mathematica scripts to run FeynArts, FeynCalc and TARCER to determine and evaluate the necessary two loop amplitudes.  We automatically determine the required basis integrals and generate C++ code to evaluate these using TSIL.  In this way the user may go from a FeynArts model file to an evaluated self energy with the ability to select amplitudes on a diagram by diagram basis.

The computation of $\mathcal{O}(10)$ amplitudes simultaneously using tools such as FeynCalc results in extremely long run times as simplifications are being attempted at the symbolic level.  On the other hand, keeping track of all terms on a diagram by diagram basis is a serious task by any manual or even semi automated method.  We offer an alternative; by completely automating this process we are able to keep track of all terms and evaluate them numerically, which on a modest computing set up is the only way to achieve this task without additional user intervention.

\end{abstract}

\tableofcontents

\section{Introduction}

The calculation of radiative corrections at the two-loop level is a computationally challenging task which has been significantly simplified with the introduction of modern tools.  Even at the most rudimentary level, determining all possible topologies is a non-trivial task, let alone the simplification of the resulting integral expressions, and finally the evaluation of these integrals.  Fortunately, FeynArts, FeynCalc, TARCER and TSIL have made each step of this process far more achievable for a wide range of users.

\section{Installation}

Before beginning the following programs are required
\begin{itemize}
\item Mathematica 9.0
\item FeynCalc 9.0 including a distribution of FeynArts and TARCER
\item TSIL 1.3
\end{itemize}

\subsection{FeynCalc}

The easiest way to install FeynCalc, FeynArts and TARCER is via the automated installation method.  Open a Mathematica notebook or kernel session and enter
\begin{lstterm}
Import["https://raw.githubusercontent.com/FeynCalc/feyncalc/master/install.m"]
InstallFeynCalc[]
\end{lstterm}

when requested to install the latest version of FeynArts say yes, as this will automatically patch the FeynArts installation.  If you do not follow this method then it is not possible to run FeynArts and FeynCalc in the same session (as we need to do) as many function names are identical between the packages, so to avoid name shadowing follow the recommend method.  For more information see the FeynCalc wiki \lstinline{https://github.com/FeynCalc/feyncalc/wiki}.

Load Tarcer by running the math kernal:
\begin{lstterm}
./MathKernal
$LoadPhi = True;
$LoadTARCER = True;
$LoadFeynArts = True;
<< FeynCalc/FeynCalc.m
\end{lstterm}
if TARCER has not been loaded this will give an error and advise the user to run
\begin{lstterm}
GenerateTarcerMX
\end{lstterm}


\subsection{TSIL}
The Two-loop Self-energy Integral Library can be downloaded from \lstinline{http://www.niu.edu/spmartin/TSIL/}.  It may installed anywhere (as Mass Builder will request the path at configuration).

\subsection{Mass Builder}
Mass Builder can be obtained from

\begin{lstterm}
https://github.com/JamesHMcKay/Mass_builder.git
\end{lstterm}

The first step is to run the configuration script to tell the program where your Mathematica kernel and TSIL installations are located.
\begin{lstterm}
./scripts/config.sh
\end{lstterm}
this will ask for the location of the Mathematica Kernal.  If using OSX the best option to try first is \lstinline{osx} (or in some rarer instances \lstinline{osx64}).  On a Linux system this is typically located in the path by default (not tested yet!), so try the \lstinline{math} shorted cut at this prompt.  If this path is incorrect, Mass Builder will compile but will not run as it can't access Mathematica.  The next prompt will ask for the folder in which the TSIL library and \lstinline{tsil_cpp.h} are located, this should be entered as the path to the folder without the \lstinline{/} at the end.  For example \lstinline{/Users/<user_name>/Programs/tsil-1.3}.

After configuration, build as normal using
\begin{lstterm}
cd build
cmake ..
make
\end{lstterm}
to compile the program.  The Mass Builder executable is now located in the root directory.

\section{Quick start guide}

In this section we give a minimalistic example to demonstrate the core features of this program and test the installation has been successful.  The example uses a simple scalar field theory with Lagrangian,
\begin{align}
\mathcal{L} = -\frac{1}{2}m^2\phi^2 - \frac{g}{3!}\phi^3-\frac{\lambda}{4!}\phi^4
\end{align}
for which we provide a FeynArts model file and the necessary Mass Builder input files in the \lstinline{models/Scalar/} directory.  For using new models it is recommended to read through the full user guide in Section \ref{sec:user_guide} to understand all available features.

\subsection{Generate FeynArts diagrams}\label{generate_diagrams}

When first approaching a problem involving radiative loop corrections having a visual list of the involved corrections is helpful.  In Mass Builder the number assigned to each radiative process, which we refer to as a \textit{diagram}, is useful information for the user to select which process to include in the calculation.  FeynArts has the capability to produce a Feynman diagram for each possible process given a model file, thus for a chosen model we call FeynArts and conveniently save this output into uniquely named Portable Document Format (\lstinline{.pdf}) files in the folder \lstinline{models/<model>/FA_diagrams/} (if this empty directory does not exist in your own model directory it must be created first).

For this example we will produce all one and two loop radiative corrections and counter term diagrams.  For this run mode we need to use the \lstinline{-f} flag (figures) and specify both the model and particle we are interested in.  This particle name must be as it appears in the FeynArts model file.  First we generate all two loop diagrams
\begin{lstterm}
mkdir models/Scalar/FA_diagrams
./mass_builder -f -m Scalar -p S[1]
\end{lstterm}
next we need to specify additional flags,
\begin{lstterm}
./mass_builder -f -m Scalar -p S[1] -l 1
./mass_builder -f -m Scalar -p S[1] -l 1 -c
./mass_builder -f -m Scalar -p S[1]  -c
\end{lstterm}
for the one-loop, one-loop counter-terms and two-loop counter terms respectively.  This will create four files in the directory \lstinline{models/Scalar/FA_diagrams/}, each file contains up to nine diagrams, the numbers refer to the FeynArts numbering system, where we will refer consistently to the last level of number (preceded by a ``N").

\subsection{Compute amplitudes}

The first non-trivial task performed by Mass Builder is taking the computed amplitude for each process and sorting it into a useful form for generating the TSIL interface.  That is, we must extract the required basis integrals and their non-zero coefficients.  The details of this algorithm are given in section \ref{sec:amplitudes}.  For this example we will compute all diagrams in the list \lstinline{models/Scalar/diagrams.txt}, see section \ref{sec:user_guide} for details on the format of this file.  To set this calculation running we simply enter
\begin{lstterm}
mkdir models/Scalar/output
./mass_builder -a -m Scalar
\end{lstterm}
which will tell Mass Builder to compute all diagrams in this specific list for the Scalar model.  Alternatively, if only a few diagrams are required one may enter
\begin{lstterm}
./mass_builder -a -m Scalar -p S[1] -d 1
\end{lstterm}
to compute diagram 1, for example.  Additional flags may also be entered here, such as \lstinline{-c} for counter term diagrams or \lstinline{-l 1} to use one loop order instead.  Finally, one may specify an alternative list rather than the default one using the flag \lstinline{-i} followed by the path to the list file.


\subsection{Generate code and evaluate}

Once the amplitudes have been computed and written into Mass Builder readable format the next step is to generate the TSIL interface.  This is conveniently separate from the previous step because computing the amplitudes is time consuming, so this is only done once.  However, one may wish to switch on and off different radiative corrections without having to rerun Mathematica.

Mass Builder keeps track of all diagrams which have been computed so we can easily generate the code for every available diagram using the command
\begin{lstterm}
./mass_builder -g -m Scalar
\end{lstterm}
alternatively one may use their own custom list by adding the additional flag \lstinline{-i} followed by the path to the list file.  

Next the generated C++ code must be compiled using the same commands used to make Mass Builder
\begin{lstterm}
cd build
make
\end{lstterm}
Now we are finally able to compute the total amplitude using the command
\begin{lstterm}
./mass_builder -e -i models/Scalar/input.txt
\end{lstterm}
where we must explicitly enter the path to an input file which contains values for the masses and couplings.  This will return the self energy
\begin{lstterm}
One-loop self energy of particle S1 = 0.0316688
Two-loop self energy of particle S1 = -3.92488e-05
\end{lstterm}
where the particle name has been converted to a more convenient form, this is the form of the particle name which appears in the generated output files.

\section{User guide}\label{sec:user_guide}

The user interface to Mass Builder is via the command line, where all modes of functionality are available depending on the chosen input flags.

The four main modes of operation are determined by the flags \lstinline{-a} for computing the amplitudes symbolic expressions, \lstinline{-g} for generating the TSIL interface code, \lstinline{-e} for the numerical evaluation of the self energy and \lstinline{-d} to request FeynArts to draw the Feynman diagrams.  At least one of these flags is required and if more than one of these flags is given the program will not run.

In addition to the run mode flag there are several additional flags, some optional and some required depending on the mode of operation.  All possible flags are
\begin{table}
\caption{The required flags for each run mode behaviour.}
\begin{tabular}{l c c c c l} 
\hline
-a & -m & & & &compute all in diagrams.txt \\
-a & -m &  && -i&compute all in specified input list\\
-a & -m & -p & -d && compute specific diagram\\
-g & -m & & &  &generate code for available diagrams\\
-g & -m &  & & -i &generate code for all in input list\\
-f & -m & -p & & &draw all diagrams\\
-e &  & & & -i&evaluate self energy\\
\hline\end{tabular}
\end{table}


\begin{lstterm}
Run modes:
-a 		compute amplitudes
-g		generate TSIL interface code
-e		evaluate self energy
-f		generate figures from FeynArts
Additional flags requiring input
-m <model> 
-p <particle>
-i  <list>
-l <loop_order>
Optional switches
-c		evaluate counter terms
-v		display Mathematica output during computation
\end{lstterm}


\subsection{Model input}

All model specific input and output is stored in the directory \lstinline{models/<model_name>/}.  For a model with name \lstinline{model} the required are
\begin{itemize}
\item model.mod  -- FeynArts model file
\item masses.txt -- list of masses and identifiers
\item couplings.txt -- list of couplings
\item diagrams.txt -- list of diagrams to compute
\end{itemize}
which are all stored in the directory \lstinline{models/models/}.  The output for each computed diagram will be stored in \lstinline{models/models/output/}, see section output for the details of these files.  For typical useage the contents of the \lstinline{output} directory is not necessary as this is an intermediate step between computation of the amplitudes and the generated C++ interface to TSIL.

The file \lstinline{masses.txt} can contain either one or two columns.  The first, and required, column must contain a list (in no particular order) of the masses exactly as they appear in the FeynArts model file.  The second column, which is highly recommended, should contain a, preferably single character, identifier for each mass in the corresponding row.  For example a typical masses file would be
\begin{lstterm}
# masses.txt
MWp          wp
MWm          wm
MZ           z
MA           a
MChi	       c
\end{lstterm}
where for even more readable output code one could choose unique one character identifiers for \lstinline{wm} and \lstinline{wp} instead.

The file \lstinline{masses.txt} is simply a one column list of couplings and constants exactly as they appear in the FeynArts model file.  This is essential for the generated code to compile and for the user input header to contain options for setting these couplings at runtime via an input file \footnote{Constants such as \lstinline{sw2} which regularly appear in couplings must be set, although the final release version will include an option to enter analytical expressions at this stage so they can be set via more sensible inputs at runtime, we will also include many standard expressions by default.}.  For example a typical couplings file would be
\begin{lstterm}
# couplings.txt
lambda
g
\end{lstterm}

Finally \lstinline{diagrams.txt} is a list of diagrams to compute.  This is identical to the file entered along with the \lstinline{-i} option at runtime.  This file contains at least two columns, the first specifies the particle name in FeynArts format (such as \lstinline{S[1]}) and the second the corresponding diagram number (to obtain a list of diagrams for each particle in \lstinline{pdf} output see section \ref{generate_diagrams}.  An optional column may be added to specify the loop order and if this is to be a counter term diagram (if these options are not set globally with the appropriate flags at runtime), including all columns this file would look like
\begin{lstterm}
# diagrams.txt
F[5]   1   2
F[5]   1   1
F[6]   2   2c
\end{lstterm}
which will tell Mass Builder to compute the first diagram for the particle \lstinline{F[5]} at one and two loop level, and the second two loop counter term diagram for particle \lstinline{F[6]}.  All numbers are in reference to the numbers given with the diagrams as listed in the \lstinline{pdf} output from \lstinline{./mass_builder -f -p <particle> -m <model>}.

\subsection{Output}

Between computing the amplitudes and generating the code Mass Builder stores the necessary information for each diagram in \lstinline{models/<model>/output/}.  This information is split into four text files
\begin{itemize}
\item \lstinline{basis_integrals_tag.txt} list of required basis integrals
\item \lstinline{coeff_integrals_tag.txt} list of coefficients of the basis integrals in C++ form
\item \lstinline{coeff_products_tag.txt} list of coefficients of the products in C++ form
\item \lstinline{summation_tag.txt} the amplitude as a sum of basis integrals and coefficients
\end{itemize}
where \lstinline{tag} encodes the particle name, diagram and loop order (and if this is a counter-term diagram).  These files are written in C++ form for simple implementation in the final generation code.



\section{Algorithm details and code structure}


\subsection{Computing the amplitudes}\label{sec:amplitudes}

The amplitudes are calculated one diagram at a time using FeynArts, FeynCalc and TARCER which is run externally to C++ using the Mathematica kernel with automatically generated scripts.  The goal in this part of the process is to determine the basis integrals which have non-zero coefficients, and what these coefficients are.  This separation into \textit{basis integrals} and \textit{coefficients} is the best way to determine which integrals are required in the final numerical calculation and to produce readable and tidy code.

The algorithm begins by evaluating the amplitude $\A$, we then compute the coefficient of every possible basis integral $\{\B_1,\B_2,.\ .\ .\ \}$.  For the non-zero coefficients, $\{\C_1,\C_2, .\ .\ .\  \}$ we then construct a trail amplitude of the form $\A_{trial} = \C_1 * \B_1 + \C_2 * \B_2 + .\ .\ .\ $ .  We then take the difference $\A - \A_{trial}$ and check for basis integrals with non-zero coefficients, this will find cross terms that have been double counted in the first step.  From within the set of basis integrals with a non-zero coefficient at this stage, $\{\B_i,\B_j,.\ .\ .\ \}$ , we create new ``basis integrals" $\B_{ij}  B_i*B_j$ which appears to Mathematica as one object.  We then construct our final trial amplitude as
\begin{align*}
 \A_{trial}\ = \ & \ \ \C_1 * \B_1 + \C_2 * \B_2 + .\ .\ .\ \\ 
  &-\frac{1}{2} \C_{12} * B_1*B_2  -\frac{1}{2} \C_{21} * B_2*B_1 - .\ .\ .\ \\
  & + C_{11} B_1*B_1 + C_{22}*B_2*B_2 + .\ .\ .\ 
\end{align*}
where $ \C_{ij}$ is the coefficient of  $\B_i*\B_j$ in the original amplitude $\A$.  If this does not equal the original amplitude then the program will throw and error and inform the user, see section \ref{errors} for details on possible causes of this scenario.  All calculations up to this point are symbolic within the generated Mathematica scripts

\subsubsection{Basis integral labelling}

A priori we have no information on the basis integrals required for a particular problem.  For an amplitude involving multiple particles there are on order hundreds of possible non-degenerate permutations of basis integrals.  Thus, when an amplitude is evaluated in Mathematica we have no generic way of identifying the integrals we need to use to reconstruct the result in the form integral times coefficient.  So we begin with all possible non-degenerate basis integrals, and quickly determine which ones have a non-zero coefficient in the resulting amplitude.  The computational time required for this process is negligible and is achieved through the use of the \lstinline{Coefficient[ Amplitude, Integral ] } Mathematica routine.  Therefore we use this ``brute force" method to reliably determine the basis integrals we require without any notable computational penalty.

During this procedure, and in the resultant generated C++ code, we need a unique identifier for each basis integral.  However, if the input masses are strings of more than one character, for example \lstinline{mHp}, \lstinline{mA0}, and \lstinline{mW}, then the obvious way to name the basis integral, $F($\lstinline{mHp},\lstinline{mHp},\lstinline{mA0},\lstinline{mA0},\lstinline{mW}$)$ would be \lstinline{F_mHpmHpmA0mA0mW} which along with being difficult to read can led to ambiguous labelling of integrals.  For example if one choose the mass labelling to be $(H^-, H^0, \chi ) = ($\lstinline{mHm},\lstinline{mH},\lstinline{m}$)$ then we easily have the degeneracy $J($\lstinline{mH},\lstinline{m},\lstinline{mHm}$) =  $\lstinline{J_mHmmHm}$ = J($\lstinline{mHm},\lstinline{mH},\lstinline{m}$)$.  When dealing with hundreds of possible permutations it is important to avoid such possibilities, however unlikely they may seem.

To overcome this we assign a unique single character identifier to each mass in the routine \lstinline{set_id}.  This will check for user input, which is the recommend action, or in the absence of this input it will attempt to assign a unique identifier to each mass.  However, this alone is not sufficient as the original FeynArts model file, and subsequent expressions will contain the original masses, so we must retain this information along with the unique identifier for each basis integral.  Therefore we create a C++ map to map the short name, using the identifiers, to a simple class of type \lstinline{Bases} which holds the following information
\begin{lstcpp}
class Bases
{
public:
string type = "";
string e1 = " ", e2 = " ", e3 = " ", e4 = " ", e5 = " ";
string coefficient = "";
string short_name = "";
Bases() {}
<constructors>
};
\end{lstcpp}
where we also we provide a constructor for each number of elements (masses).  For example the basis integral $V($\lstinline{mHp},\lstinline{mA0},\lstinline{mA0},\lstinline{mW}$)$ is initialised as\begin{lstcpp}
Bases base("V",mA0,mA0,mW);
\end{lstcpp}
which we then save in \lstinline{std::map<std::string, Bases>} to the integrals short name.

This set up significantly simplifies the entire algorithm, as we no longer need to pull apart basis integral identiiers, such as \lstinline{F_abcde} character by character to reconstruct and print out the integral in a useful form for either FeynCalc or TSIL, and indeed this would not be possible if any of the identifiers were not a single character.  This also enables a huge flexibility in the mass labelling, in practice one may use whatever name they want for the masses without sacrificing final code readability.



\subsection{The TSIL interface}

The generated C++ interface to TSIL is organised on a diagram by diagram basis.  However, during the generation of this code the basis integrals required for all diagrams in the chosen set are amalgamated and reduced to a minimalistic set.  This set is evaluated in one function and made globally available \footnote{Taking account of symmetries can reduce the number of basis integral evaluations required, we already have a routine available to automatically determine the optimum set of integrals for one family of these integrals, and this will be included with the final version of Mass Builder.}

The generated code, located in \lstinline{src/self_energy.cpp} takes the following structure
\begin{lstcpp}
TSIL_COMPLEXCPP  <basis integral declarations> ;
TSIL_REAL  <mass declarations>;
TSIL_REAL  <coupling declarations> ;

void DoTSIL(TSIL_REAL s,TSIL_REAL Q2)
{
< TSIL basis integral evaluations >
}

void init(Data data) 
{
< set couplings & masses from data >
}

TSIL_COMPLEXCPP  diagram_1()
{
TSIL_COMPLEXCPP C =  <Coefficient>;
return  + C * <basis_integral>;
}

TSIL_COMPLEXCPP  diagram_2()
{
TSIL_COMPLEXCPP C =  <Coefficient>;
return  + C * <basis_integral>;
}

void Self_energy::run_tsil (Data &data) 
{
TSIL_COMPLEXCPP SE_particle = diagram_1() + diagram_2();
data.SE["particle"] = real(SE_particle);
}
\end{lstcpp}

where we have one subroutine to call TSIL and compute the basis integrals, and a subroutine for each diagram, where the subroutine names will encode the particle name, diagram number and loop order (and if it is a counter term diagram or not).  The routine \lstinline{run_tsil} will fill the self energy map for each available particle (in practice we have a map for both the one and two loop self energies separately).

Along with the above source code a header file, \lstinline{data.hpp}, is also generated in the \lstinline{include/} directory to hold the model data.  This header contains a class definition of type \lstinline{Data} which is designed to manage the input and output of information from the self energy calculator.   This class contains declarations for each coupling defined in \lstinline{couplings.txt}, and for each mass in \lstinline{masses.txt}.  It also holds a vector of strings with the name \lstinline{avail_part} containing the short names of all particles for which amplitudes are available, along with two maps of type \cpp{map<std::string,double>} \lstinline{SE_1} and \lstinline{SE_2} which hold the names of the particles and the one-loop and two-loop self energies respectively .  Finally, it includes the functions which read the runtime input of values for the couplings and masses relevant for this model.  By dynamically updating this class when generating the self energy interface we enable user input of these quantities and a dynamic mapping interface to other functions in the code.

Before code is generated \lstinline{self_energy.cpp} is a skeleton code necessary for the rest of Mass Builder to compile successfully.  If \lstinline{self_energy.cpp} or \lstinline{data.hpp} becomes corrupted and the rest of the code no longer compiles, which is likely if \lstinline{couplings.txt} is missing a variable name, then the skeleton code can be restored by simply running scripts/config.sh again.

The diagrams available to be included in the generated TSIL interface are registered in \lstinline{models/<model>/output/avail_diagrams.txt} which is updated each time a new diagram is computed (it is also checked for duplicate entries, so no diagram, particle, and type combination appears twice).  However, if using the \lstinline{-i} option with the generate code mode, then it is possible for duplicate diagrams to appear (we choose not to override this possibility to avoid unnecessary interference with user input).



\section{Applications}

\subsection{Electroweak mass splittings}

With Mass Builder we provide an optional executable to demonstrate more advanced use of the program.  This example calculates mass splitting in an electroweak triplet using one or two loop self energies.  Before making this executable the appropriate TSIL interface code must generated, as it relies on the \lstinline{Data} class containing particular masses and particle names.

To build this example with 1-loop self energies run the following commands
\begin{lstterm}
./mass_builder -a -m MDM -i models/MDM/example_list.txt
./mass_builder -g -m MDM -i models/MDM/example_list.txt
cd build
make
make example
\end{lstterm}
where this list contains all one-loop diagrams.  After building the example executable with the above commands now return the root directory and run
\begin{lstterm}
./example -i models/MDM/input.txt
\end{lstterm}
where the input list here contains the required standard model couplings and masses.  This will produce a data file in the model output directory called \lstinline{mass_splittings.txt}.  If you have Python installed this can be plotted simply by running
\begin{lstterm}
python src/plot_example.py
\end{lstterm}

\begin{figure}
\centering
\includegraphics[width=0.5\textwidth]{mass_splittings.eps}
\caption{.}\label{fig:1_loop}
\end{figure}




\subsection{Two Higgs doublet model}





\bibliography{../../../Papers/library}{}


\end{document}  